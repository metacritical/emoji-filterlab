<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Emoji Filter Lab – CSS Filter Playground</title>
  <meta name="description" content="CSS filter playground to tint emojis. Adjust hue, saturation, brightness, contrast, sepia, invert, and more. Copy the generated CSS and HTML for your design.">
  <meta name="keywords" content="emoji, css filters, hue-rotate, tint emoji, brightness, contrast, design tool, overlay, ui playground">
  <meta property="og:title" content="Emoji Filter Lab – CSS filter playground for emoji tinting">
  <meta property="og:description" content="Experiment with CSS filters to tint emojis. Dark-themed editor with sliders for hue, saturation, brightness, etc. Copy-ready CSS and HTML.">
<style>
  * { font-variant-emoji: emoji; box-sizing: border-box; }
  body { margin: 0; padding: 20px; background: #050a14; font-family: system-ui, -apple-system, sans-serif; }
  :root{ --bg:#0b1220; --panel:#121a2b; --accent:#cc342d; --muted:#9ca3af; --text:#e5e7eb; --mono:'JetBrains Mono',ui-monospace,Menlo,Monaco,Consolas,'Liberation Mono','Courier New',monospace; --sans: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, sans-serif; --emoji: 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji', 'Android Emoji', 'EmojiOne Color', sans-serif; }
  .lab-root{ background:var(--bg); color:var(--text); border-radius:10px; padding:16px; max-width: 1400px; margin: 0 auto; }
  .lab-header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px}
  .lab-title{margin:0;font-size:1.25rem;font-weight:700}
  .lab-hint{color:var(--muted);font-size:.9rem}
  .lab-wrap{display:grid;grid-auto-rows:auto;gap:16px}
  .top-row{display:grid;grid-template-columns: minmax(0,1fr) minmax(0,1.6fr); gap:16px; align-items:start}
  .two-col{display:grid; grid-template-columns: minmax(0,1fr) minmax(0,1.6fr); gap:16px}
  .lab-panel{background:var(--panel);border:1px solid #1f2a44;border-radius:10px;padding:14px;overflow:visible; width:100%;}
  .controls{display:grid;gap:10px}
  .group{background:rgba(255,255,255,.03);border:1px solid #22304f;padding:10px;border-radius:8px}
  .group h3{margin:0 0 8px;font-size:.95rem;color:#cbd5e1}
  label{display:grid;grid-template-columns: 1fr minmax(120px,1fr);align-items:center;gap:10px;font-size:.9rem}
  input[type="range"]{width:100%}
  input[type="color"], input[type="text"], input[type="number"], textarea{width:100%;background:#0f1626;color:var(--text);border:1px solid #293656;border-radius:6px;padding:6px; font-family:var(--sans)}
  .emoji-font, .emoji-font *, #emojiInput, #emojiNode, .preview, .preview * { font-family: var(--emoji) !important; }
  .mono{font-family:var(--mono)}
  .editor-wrap{display:grid;grid-template-rows:auto 1fr auto;gap:10px;min-height:0}
  .editor{min-height:180px;background:#0f172a;border:1px solid #1e293b;border-radius:10px;padding:16px;overflow:auto;font-family:var(--mono); font-size:18px;line-height:1.5}
  .editor .emoji{display:inline-block; font-family: var(--emoji) !important;}
  .preview{display:flex;align-items:center;gap:10px;font-size:112px; font-family: var(--emoji) !important;}
  .preview .emoji{display:inline-block; font-family: var(--emoji) !important;}
  .row{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  .btn{background:var(--accent);color:#fff;border:none;padding:8px 12px;border-radius:8px;cursor:pointer}
  .btn:hover{opacity:0.9}
  .btn.secondary{background:#334155}
  .small{font-size:.85rem;color:var(--muted)}
  .code{background:#0b1220;border:1px solid #1e293b;padding:8px;border-radius:8px;white-space:pre-wrap; color:var(--text)}
  textarea.code{width:100%; min-height:3.5rem}
  .toast{position:fixed; right:16px; bottom:16px; background:#16a34a; color:#fff; padding:8px 12px; border-radius:8px; opacity:0; transform:translateY(10px); transition:all .2s ease; pointer-events:none}
  .toast.show{opacity:1; transform:translateY(0)}
  @media (max-width: 768px) {
    .top-row, .two-col { grid-template-columns: 1fr; }
    .lab-header { flex-direction: column; align-items: flex-start; }
  }
</style>
</head>
<body>
<div class="lab-root">
  <div class="lab-header">
    <h2 class="lab-title">Emoji Filter Lab</h2>
    <div class="lab-hint">Tune CSS filters to tint emojis. Copy CSS + HTML when you like the color.</div>
  </div>
  <div class="lab-wrap">
    <div class="top-row">
      <aside class="lab-panel">
      <div class="controls">
        <div class="group">
          <h3>Emoji preview</h3>
          <div class="preview emoji-font"><span id="emojiNode" class="emoji">&#x1F48E;</span></div>
          <div class="row">
            <label>Emoji <input id="emojiInput" class="emoji-font" type="text" value="&#x1F48E;" maxlength="8" /></label>
            <label>Size (px) <input id="emojiSize" type="number" value="112" min="12" max="256" /></label>
          </div>
        </div>
      </div>
      </aside>
      <main class="lab-panel editor-wrap">
        <div class="row">
          <strong>Live editor</strong>
          <span class="small">Type text and emojis below. Text color & background apply here.</span>
        </div>
        <div id="editor" class="editor" contenteditable="true">&#x1F48E; Hello! &#x2728; Type and tint emojis.</div>
        <div class="small">Tip: Select any emoji in the editor to preview it. All emojis adopt the current filter automatically.</div>
      </main>
    </div>
    <div class="two-col">
    <aside class="lab-panel">
      <div class="controls">
        <div class="group">
          <h3>Text & background</h3>
          <label>Text color <input id="textColor" type="color" value="#e5e7eb"/></label>
          <label>Background <input id="bgColor" type="color" value="#0f172a"/></label>
          <label>Font size (px) <input id="fontSize" type="number" value="18" min="12" max="48"/></label>
        </div>
        <div class="group">
          <h3>Snippets</h3>
          <div class="small">HTML snippet (copy):</div>
          <div id="htmlSnippet" class="code mono"></div>
          <button id="copyHtml" class="btn secondary" type="button">Copy HTML</button>
        </div>
      </div>
    </aside>
    <aside class="lab-panel">
      <div class="controls">
        <div class="group">
          <h3>Filter sliders & CSS</h3>
          <label>Hue rotate (deg) <input id="hue" type="range" min="0" max="360" value="240"/></label>
          <label>Saturate <input id="saturate" type="range" min="0" max="5" step="0.1" value="1.5"/></label>
          <label>Brightness <input id="brightness" type="range" min="0" max="2" step="0.05" value="1.1"/></label>
          <label>Contrast <input id="contrast" type="range" min="0" max="2" step="0.05" value="1"/></label>
          <label>Sepia <input id="sepia" type="range" min="0" max="1" step="0.01" value="0"/></label>
          <label>Invert <input id="invert" type="range" min="0" max="1" step="0.01" value="0"/></label>
          <label>Grayscale <input id="grayscale" type="range" min="0" max="1" step="0.01" value="0"/></label>
          <label>Opacity <input id="opacity" type="range" min="0.1" max="1" step="0.01" value="1"/></label>
          <div class="small">Filter CSS (editable):</div>
          <textarea id="filterCss" class="code mono" rows="3"></textarea>
          <button id="copyFilter" class="btn" type="button">Copy filter()</button>
        </div>
      </div>
    </aside>
    </div>
  </div>
  <div id="toast" class="toast" role="status" aria-live="polite">Copied!</div>
</div>
<script>
  const $ = s => document.querySelector(s);
  const emojiNode = $('#emojiNode');
  const emojiInput = $('#emojiInput');
  const sizeInput = $('#emojiSize');
  const filterCss = $('#filterCss');
  const htmlSnippet = $('#htmlSnippet');
  const editor = $('#editor');
  const sliders = ['hue','saturate','brightness','contrast','sepia','invert','grayscale','opacity'].map(id=>$('#'+id));
  
  function buildFilter(){
    const v = {hue:$('#hue').value, sat:$('#saturate').value, bri:$('#brightness').value, con:$('#contrast').value, sep:$('#sepia').value, inv:$('#invert').value, gry:$('#grayscale').value, op:$('#opacity').value};
    return `hue-rotate(${v.hue}deg) saturate(${v.sat}) brightness(${v.bri}) contrast(${v.con}) sepia(${v.sep}) invert(${v.inv}) grayscale(${v.gry}) opacity(${v.op})`;
  }
  
  function applyFilterString(str, preserveCursor = false){
    // set preview
    emojiNode.style.cssText = `filter: ${str}; font-size:${sizeInput.value||112}px;`;
    filterCss.value = `filter: ${str};`;
    htmlSnippet.textContent = `<span style="filter: ${str};">${(emojiInput.value||'\uD83D\uDC8E')}</span>`;
    
    // Only update editor innerHTML when NOT typing (preserveCursor=false) to avoid cursor jumping
    if (!preserveCursor) {
      const emojiRegex = /(\p{Extended_Pictographic})/gu;
      const text = editor.textContent;
      editor.innerHTML = text.replace(emojiRegex, (m)=>`<span class="emoji" style="filter:${str};">${m}</span>`);
    }
    
    // Update ONLY editor text/background color (not the entire lab)
    editor.style.color = $('#textColor').value;
    editor.style.background = $('#bgColor').value;
    editor.style.fontSize = (parseInt($('#fontSize').value)||18) + 'px';
  }
  
  function render(){
    const content = emojiInput.value || '\uD83D\uDC8E';
    // Use Intl.Segmenter for proper emoji grapheme cluster extraction
    let glyph = '\uD83D\uDC8E';
    if (content.trim()) {
      if (typeof Intl !== 'undefined' && Intl.Segmenter) {
        const segmenter = new Intl.Segmenter('en', { granularity: 'grapheme' });
        const segments = Array.from(segmenter.segment(content.trim()));
        glyph = segments.length > 0 ? segments[0].segment : content.trim().charAt(0);
      } else {
        // Fallback: use spread operator which handles most emoji
        const chars = [...content.trim()];
        glyph = chars.length > 0 ? chars[0] : content.trim().charAt(0);
      }
    }
    emojiNode.textContent = glyph;
    applyFilterString(buildFilter());
  }
  
  sliders.forEach(s=> s.addEventListener('input', render));
  [emojiInput,sizeInput,$('#textColor'),$('#bgColor'),$('#fontSize')].forEach(i=> i.addEventListener('input', render));
  
  // If textarea edited manually, auto-apply
  filterCss.addEventListener('input', ()=>{
    const v = (filterCss.value||'').replace(/^\s*filter\s*:\s*/,'').replace(/;\s*$/,'');
    if(v) applyFilterString(v);
  });
  
  $('#copyFilter').addEventListener('click', ()=>{ 
    navigator.clipboard.writeText(filterCss.value||'').then(()=>{
      const t=$('#toast'); t.textContent='Filter copied!'; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),1200);
    }).catch(()=>{});
  });
  
  $('#copyHtml').addEventListener('click', ()=>{ 
    navigator.clipboard.writeText(htmlSnippet.textContent).then(()=>{
      const t=$('#toast'); t.textContent='HTML copied!'; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),1200);
    }).catch(()=>{});
  });
  
  // When typing in editor, preserve cursor position by not re-rendering innerHTML
  editor.addEventListener('input', ()=>{ 
    // Just update styles, don't touch innerHTML to preserve cursor
    editor.style.color = $('#textColor').value;
    editor.style.background = $('#bgColor').value;
    editor.style.fontSize = (parseInt($('#fontSize').value)||18) + 'px';
  });
  
  // Auto-update preview when selecting emoji in editor
  function updatePreviewFromSelection() {
    const selection = window.getSelection();
    if (!selection.rangeCount) return;
    
    const selectedText = selection.toString().trim();
    if (!selectedText) return;
    
    // Check if selection contains an emoji
    const emojiRegex = /\p{Extended_Pictographic}/u;
    if (emojiRegex.test(selectedText)) {
      // Extract first emoji from selection
      let firstEmoji = '';
      if (typeof Intl !== 'undefined' && Intl.Segmenter) {
        const segmenter = new Intl.Segmenter('en', { granularity: 'grapheme' });
        const segments = Array.from(segmenter.segment(selectedText));
        // Find first emoji segment
        for (const segment of segments) {
          if (emojiRegex.test(segment.segment)) {
            firstEmoji = segment.segment;
            break;
          }
        }
      } else {
        const chars = [...selectedText];
        for (const char of chars) {
          if (emojiRegex.test(char)) {
            firstEmoji = char;
            break;
          }
        }
      }
      
      if (firstEmoji) {
        emojiInput.value = firstEmoji;
        render();
      }
    }
  }
  
  editor.addEventListener('mouseup', updatePreviewFromSelection);
  editor.addEventListener('keyup', updatePreviewFromSelection);
  editor.addEventListener('touchend', updatePreviewFromSelection);
  
  render();
</script>
</body>
</html>
